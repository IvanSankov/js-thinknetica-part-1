'use strict';

/*
* 1. В общем, я пытался сразу сделать с возможностью чейнинга, именно по этому у меня есть "странные" функции типа
* nthen и ncatch. Если делать по обязательному заданию, то в качестве then надо просто вызывать nthen, тогда будет
* функциональность, как на лекции делали.
* 2. В чейнинге возникла проблема, в обычном промисе я так понял, что после каждого then создается клон текущего promise
* но в этом случае если мы сделаем promise.then(cb).then(cb2).then(cb3), у нас создастся один промис при
* promise.then(cb), еще один промис при .then(cb2) и еще один промис при .then(cb2), т.е. у нас будет 4 промиса:
* promise
* promise.then(cb)
* promise.then(cb).then(cb2)
* promise.then(cb).then(cb2).then(cb3)
* Значит фукция сb вызовется 3 раза, cb2 2 раза и cb3 один раз. А это не хорошо.
* Если модифицировать текущий объект, тогда два разных вызова
* promise.then(cb)
* promise.then(cb2)
* Будут зависить друг от друга. Поэтому не совсем ясно, как там внутри, определяется, когда нужно создавать новый промис
* а когда надо модифицировать текущий. Поэтому я добавил по одной функции nthen и ncatch, которые делают то же самое, что
* и then и catch, соответсвенно, но возвращают клонированный объект, а не себя. Как сделать без доп функций. Я не знаю. :-(
*
*
*
* */